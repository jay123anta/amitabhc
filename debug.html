<!DOCTYPE html>
<html>
<head>
    <title>Complete SHABD Function Debug Test</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #fff; }
        #output { background: #000; padding: 15px; border-radius: 5px; margin: 20px 0; max-height: 600px; overflow-y: auto; }
        button { background: #ff9933; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #e67e00; }
        .success { color: #4ade80; }
        .error { color: #ef4444; }
        .warning { color: #f59e0b; }
        .info { color: #3b82f6; }
        h2 { color: #ff9933; }
        h3 { color: #10b981; }
        hr { border-color: #374151; }
    </style>
</head>
<body>
    <h2>üêõ Complete SHABD Function Debug Test</h2>
    <button onclick="runBasicTest()">1. Basic Test</button>
    <button onclick="runRegexTest()">2. Regex Test</button>
    <button onclick="runFullTest()">3. Full SHABD Test</button>
    <button onclick="clearOutput()">Clear Output</button>
    
    <div id="output"></div>

    <!-- Load the interpreter directly -->
    <script>
        /**
         * Inline SecureAmitabhCInterpreter for debugging
         * This is a minimal version focused on SHABD functions
         */
        class SecureAmitabhCInterpreter {
            constructor() {
                this.variables = Object.create(null);
                this.outputCallback = null;
                this.maxStringLength = 10000;
                this.reservedWords = new Set(['__proto__', 'constructor']);
            }

            setOutputCallback(callback) {
                if (typeof callback === 'function') {
                    this.outputCallback = callback;
                }
            }

            output(message) {
                if (this.outputCallback) {
                    this.outputCallback(message);
                } else {
                    console.log(message);
                }
            }

            sanitizeString(str) {
                return String(str || '').slice(0, this.maxStringLength);
            }

            parseExpression(expr) {
                console.log('üîç parseExpression called with:', JSON.stringify(expr));
                
                if (!expr || typeof expr !== 'string') {
                    console.log('‚ùå Invalid expression');
                    return '';
                }

                expr = expr.trim();
                console.log('üßπ Cleaned expression:', JSON.stringify(expr));

                // String literal
                if ((expr.startsWith('"') && expr.endsWith('"')) || 
                    (expr.startsWith("'") && expr.endsWith("'"))) {
                    const result = expr.slice(1, -1);
                    console.log('üìù String literal result:', JSON.stringify(result));
                    return result;
                }

                // Built-in function calls - CHECK THIS FIRST
                if (expr.includes('.') && expr.includes('(')) {
                    console.log('üéØ Potential built-in function detected');
                    const builtInMatch = expr.match(/^(SHABD|GANIT|KHAZANA|SAMAY)\.(\w+)\s*\((.*)\)$/);
                    console.log('üß™ Built-in regex match:', builtInMatch);
                    
                    if (builtInMatch) {
                        console.log('‚úÖ SHABD function matched!');
                        return this.evaluateBuiltInFunction(expr);
                    }
                }

                // Regular function calls
                const funcCallMatch = expr.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)$/);
                if (funcCallMatch) {
                    console.log('‚ö†Ô∏è Regular function call detected:', funcCallMatch[1]);
                    throw new Error(`Function '${funcCallMatch[1]}' not found`);
                }

                // Variable lookup
                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(expr)) {
                    console.log('üî§ Variable lookup:', expr);
                    return this.variables[expr] || expr;
                }

                console.log('üîÑ Returning expression as-is:', expr);
                return expr;
            }

            evaluateBuiltInFunction(expr) {
                console.log('üîß evaluateBuiltInFunction called with:', JSON.stringify(expr));
                
                const match = expr.match(/^(SHABD|GANIT|KHAZANA|SAMAY)\.(\w+)\s*\((.*)\)$/);
                if (!match) {
                    throw new Error(`Invalid built-in function call: ${expr}`);
                }
                
                const [, namespace, functionName, argsStr] = match;
                console.log('üìä Parsed function:', { namespace, functionName, argsStr });
                
                const args = argsStr ? this.parseArrayItems(argsStr).map(arg => this.parseExpression(arg)) : [];
                console.log('üìã Parsed args:', args);
                
                switch (namespace) {
                    case 'SHABD':
                        return this.evaluateStringFunction(functionName, args);
                    default:
                        throw new Error(`Namespace ${namespace} not implemented yet`);
                }
            }

            parseArrayItems(content) {
                console.log('üì¶ parseArrayItems called with:', JSON.stringify(content));
                
                if (!content.trim()) {
                    return [];
                }
                
                // Simple comma-split for now (could be enhanced)
                const items = [];
                let current = '';
                let depth = 0;
                let inString = false;
                let stringChar = '';
                
                for (let i = 0; i < content.length; i++) {
                    const char = content[i];
                    
                    if ((char === '"' || char === "'") && !inString) {
                        inString = true;
                        stringChar = char;
                    } else if (char === stringChar && inString) {
                        inString = false;
                        stringChar = '';
                    }
                    
                    if (!inString) {
                        if (char === '(') depth++;
                        if (char === ')') depth--;
                        
                        if (char === ',' && depth === 0) {
                            if (current.trim()) {
                                items.push(current.trim());
                            }
                            current = '';
                            continue;
                        }
                    }
                    
                    current += char;
                }
                
                if (current.trim()) {
                    items.push(current.trim());
                }
                
                console.log('üì¶ parseArrayItems result:', items);
                return items;
            }

            evaluateStringFunction(functionName, args) {
                console.log('üìù evaluateStringFunction called:', { functionName, args });
                
                if (args.length === 0) {
                    throw new Error(`SHABD.${functionName} requires at least one argument`);
                }
                
                const str = String(args[0]);
                console.log('üìù Processing string:', JSON.stringify(str));
                
                switch (functionName) {
                    case 'length':
                        const result = str.length;
                        console.log('üìè SHABD.length result:', result);
                        return result;
                        
                    case 'uppercase':
                        const upper = str.toUpperCase();
                        console.log('üî† SHABD.uppercase result:', JSON.stringify(upper));
                        return upper;
                        
                    case 'lowercase':
                        const lower = str.toLowerCase();
                        console.log('üî° SHABD.lowercase result:', JSON.stringify(lower));
                        return lower;
                        
                    case 'contains':
                        if (args.length < 2) {
                            throw new Error('SHABD.contains requires two arguments');
                        }
                        const searchStr = String(args[1]);
                        const contains = str.includes(searchStr);
                        console.log('üîç SHABD.contains result:', contains);
                        return contains ? 'SHAKTI' : 'KAALIA';
                        
                    default:
                        throw new Error(`Unknown SHABD function: ${functionName}`);
                }
            }

            executeBolo(line) {
                console.log('üì¢ executeBolo called with:', JSON.stringify(line));
                
                const match = line.match(/BOLO\s+(.+)/);
                if (match) {
                    const expression = match[1].trim();
                    console.log('üì¢ BOLO expression:', JSON.stringify(expression));
                    
                    try {
                        const value = this.parseExpression(expression);
                        console.log('üì¢ BOLO evaluated to:', JSON.stringify(value));
                        this.output(String(value));
                    } catch (error) {
                        console.log('‚ùå BOLO evaluation failed:', error.message);
                        this.output(expression);
                    }
                }
            }

            async run(code) {
                console.log('üöÄ Starting run with code:', JSON.stringify(code));
                
                try {
                    const lines = code.split('\n')
                        .map(line => line.trim())
                        .filter(line => line && !line.startsWith('//'));
                    
                    console.log('üìã Parsed lines:', lines);
                    
                    let started = false;
                    
                    for (const line of lines) {
                        console.log('üîÑ Processing line:', JSON.stringify(line));
                        
                        if (line === 'LIGHTS') {
                            started = true;
                            continue;
                        }
                        
                        if (line === 'CAMERA' || line === 'ACTION') {
                            continue;
                        }
                        
                        if (!started) continue;
                        
                        if (line.startsWith('BOLO')) {
                            this.executeBolo(line);
                        }
                    }
                    
                    return { success: true };
                    
                } catch (error) {
                    console.log('‚ùå Run failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }

        // Debug functions
        function addOutput(message, type = 'info') {
            const output = document.getElementById('output');
            const div = document.createElement('div');
            div.className = type;
            div.innerHTML = message;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = '';
        }

        function runBasicTest() {
            addOutput('<h3>üß™ Basic Test</h3>');
            
            if (typeof SecureAmitabhCInterpreter === 'undefined') {
                addOutput('‚ùå SecureAmitabhCInterpreter not found!', 'error');
                return;
            }
            
            addOutput('‚úÖ SecureAmitabhCInterpreter found', 'success');
            
            const interpreter = new SecureAmitabhCInterpreter();
            addOutput('‚úÖ Interpreter created', 'success');
            
            // Test if methods exist
            const methods = ['parseExpression', 'evaluateBuiltInFunction', 'evaluateStringFunction'];
            methods.forEach(method => {
                if (typeof interpreter[method] === 'function') {
                    addOutput(`‚úÖ ${method} method exists`, 'success');
                } else {
                    addOutput(`‚ùå ${method} method missing`, 'error');
                }
            });
            
            addOutput('<hr>');
        }

        function runRegexTest() {
            addOutput('<h3>üîç Regex Pattern Test</h3>');
            
            const testExpressions = [
                'SHABD.length("test")',
                'SHABD.uppercase("hello world")',
                'SHABD.contains("hello", "world")',  
                'normalFunction("test")'
            ];

            const builtInRegex = /^(SHABD|GANIT|KHAZANA|SAMAY)\.(\w+)\s*\((.*)\)$/;
            const regularFuncRegex = /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)$/;

            testExpressions.forEach(expr => {
                addOutput(`<strong>Testing:</strong> ${expr}`);
                
                const builtInMatch = expr.match(builtInRegex);
                const regularMatch = expr.match(regularFuncRegex);
                
                if (builtInMatch) {
                    addOutput(`‚úÖ Built-in match: ${builtInMatch[1]}.${builtInMatch[2]}(${builtInMatch[3]})`, 'success');
                }
                
                if (regularMatch && !builtInMatch) {
                    addOutput(`‚ö†Ô∏è Regular function match: ${regularMatch[1]}(${regularMatch[2]})`, 'warning');
                }
                
                if (!builtInMatch && !regularMatch) {
                    addOutput(`‚ùå No match found`, 'error');
                }
                
                addOutput('');
            });
            
            addOutput('<hr>');
        }

        function runFullTest() {
            addOutput('<h3>üéØ Full SHABD Function Test</h3>');
            
            const interpreter = new SecureAmitabhCInterpreter();
            interpreter.setOutputCallback((msg) => addOutput(`OUTPUT: ${msg}`, 'info'));
            
            const testCodes = [
                {
                    name: 'SHABD.length test',
                    code: `LIGHTS
CAMERA
    BOLO SHABD.length("hello")
ACTION`
                },
                {
                    name: 'SHABD.uppercase test', 
                    code: `LIGHTS
CAMERA
    BOLO SHABD.uppercase("hello world")
ACTION`
                },
                {
                    name: 'SHABD.contains test',
                    code: `LIGHTS
CAMERA
    BOLO SHABD.contains("hello world", "world")
ACTION`
                }
            ];

            testCodes.forEach(async (test) => {
                addOutput(`<strong>Running:</strong> ${test.name}`);
                
                try {
                    const result = await interpreter.run(test.code);
                    if (result.success) {
                        addOutput(`‚úÖ ${test.name} completed successfully`, 'success');
                    } else {
                        addOutput(`‚ùå ${test.name} failed: ${result.error}`, 'error');
                    }
                } catch (error) {
                    addOutput(`‚ùå ${test.name} crashed: ${error.message}`, 'error');
                }
                
                addOutput('');
            });
            
            addOutput('<hr>');
        }

        // Auto-run basic test on load
        window.addEventListener('load', () => {
            addOutput('<h2>üêõ SHABD Function Debug Console</h2>');
            addOutput('Console ready. Click buttons above to run tests.');
            addOutput('<hr>');
        });
    </script>
</body>
</html>